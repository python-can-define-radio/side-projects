<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>2D Wave Simulator</title>
  <style>
    canvas {
      border: 10px solid black;
      display: block;
      margin: 80px auto;
    }
  </style>
</head>

<body>
  <div style="text-align: center; font-family: sans-serif;">
    Field measurement at chosen point: <span id="strengthDisplay">0.00</span>
  </div>
  <canvas id="waveCanvas" width="500" height="500"></canvas>
  <script>
    const canvas = document.getElementById('waveCanvas');
    const ctx = canvas.getContext('2d');
    const size = 500;
    const damping = .99;
    const recvx = 197;
    const recvy = 24;

    // Define obstacle mask
    const obstacle = Array.from({ length: size }, () => new Uint8Array(size));

    // Example: a vertical wall from (150, 100) to (150, 200)
    for (let y = 100; y <= 200; y++) {
      for (let x = 150; x <= 180; x++) {
        obstacle[y][x] = 1;
      }
    }


    // Create 2D arrays for current, previous, and next wave states
    const current = Array.from({ length: size }, () => new Float32Array(size));
    const previous = Array.from({ length: size }, () => new Float32Array(size));

    // Add a pulse at the center
    current[20][200] = 2000000;

    function updateWave() {
      const next = Array.from({ length: size }, () => new Float32Array(size));

      for (let y = 1; y < size - 1; y++) {
        for (let x = 1; x < size - 1; x++) {
          if (obstacle[y][x]) continue; // Skip obstacle cells

          next[y][x] = (
            (current[y + 1][x] + current[y - 1][x] + current[y][x + 1] + current[y][x - 1]) / 2
            - previous[y][x]
          ) * damping;
        }
      }


      function draw() {
      const imageData = ctx.createImageData(size, size);
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const idx = (y * size + x) * 4;
          if (obstacle[y][x]) {
            imageData.data[idx] = 0;     // black
            imageData.data[idx + 1] = 0;
            imageData.data[idx + 2] = 0;
            imageData.data[idx + 3] = 255;
          } else if (Math.abs(x - recvx) < 3 && Math.abs(y - recvy) < 3) {
            imageData.data[idx] = 255;
            imageData.data[idx + 1] = 0;
            imageData.data[idx + 2] = 0;
            imageData.data[idx + 3] = 255;
          } else {
            const val = Math.floor(127 + 127 * current[y][x]);
            imageData.data[idx] = val;
            imageData.data[idx + 1] = val;
            imageData.data[idx + 2] = val;
            imageData.data[idx + 3] = 255;
          }
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

      // Swap buffers
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          previous[y][x] = current[y][x];
          current[y][x] = next[y][x];
        }
      }

      document.getElementById('strengthDisplay').textContent =
        current[recvy][recvx].toFixed(4);

        setTimeout(() => requestAnimationFrame(updateWave), 800);
    }

    updateWave();
  </script>
</body>

</html>
