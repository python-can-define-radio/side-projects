<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js – Capsule + Octree FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #reticule {
            position: fixed;
            left: 50%;
            top: 50%;
            width: 16px;
            height: 16px;
            margin-left: -8px;
            margin-top: -8px;
            pointer-events: none;
        }

        #reticule span {
            position: absolute;
            background: white;
        }

        #reticule span:nth-child(1) {
            left: 7px;
            top: 0;
            width: 2px;
            height: 16px;
        }

        #reticule span:nth-child(2) {
            top: 7px;
            left: 0;
            width: 16px;
            height: 2px;
        }

        #startScreen {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, #222, #000);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            font-family: monospace;
        }

        #startPanel {
            background: rgba(20, 20, 20, 0.95);
            padding: 24px 32px;
            border: 1px solid #555;
            width: 320px;
            text-align: center;
        }

        #startPanel h1 {
            margin-bottom: 20px;
        }

        #startPanel label {
            display: block;
            margin-bottom: 16px;
            text-align: left;
        }

        #startPanel input {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            background: #111;
            border: 1px solid #555;
            color: white;
        }

        .avatarSelect {
            margin-bottom: 20px;
        }

        .avatarPreview {
            border: 1px solid #555;
            padding: 12px;
            margin: 8px 0;
            background: #111;
        }

        .menuButton {
            width: 100%;
            padding: 10px;
            border: none;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        /* Start Game (green) */
        .menuButton.start {
            background: #2ecc71;
        }

        .menuButton.start:hover {
            background: #27ae60;
        }

        /* Settings (neutral) */
        .menuButton.settings {
            background: #3498db;
        }

        .menuButton.settings:hover {
            background: #2980b9;
        }

        #settingsScreen {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            color: white;
            font-family: monospace;
        }

        #settingsPanel {
            background: rgba(20, 20, 20, 0.95);
            padding: 24px 32px;
            border: 1px solid #555;
            width: 320px;
            text-align: center;
        }

        #settingsPanel label {
            display: block;
            margin: 16px 0;
            text-align: left;
        }

        #settingsPanel input[type="range"] {
            width: 100%;
        }

        #settingsPanel {
            position: relative;
        }

        /* Red close X */
        #closeSettings {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            background: #c0392b;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            line-height: 28px;
            cursor: pointer;
        }

        #closeSettings:hover {
            background: #e74c3c;
        }
    </style>
</head>

<body>
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4( color * vColor, 1.0 );
            gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        }
    </script>

    <div id="reticule">
        <span></span>
        <span></span>
    </div>
    <div id="hud" style="position:fixed; top:10px; left:10px; color:white; font-family:monospace;">
        <div id="usernameHud" style="margin-bottom:6px; font-weight:bold;"></div>
        Yaw: <span id="yawtext"></span><br>
        Pos:
        <span style="color:#ed8711;">X:</span> <span id="posx"></span>
        <span style="color:#d2ef1b; margin-left:6px;">Y:</span> <span id="posy"></span>
        <span style="color:#4488ff; margin-left:6px;">Z:</span> <span id="posz"></span>
        <div id="pyodideStatus" style="margin-top:6px; color:#aaa;">Pyodide: loading…</div>
    </div>

    <div id="startScreen">
        <div id="startPanel">
            <h1>Start Game</h1>

            <label>
                Username
                <input id="usernameInput" type="text" maxlength="16" placeholder="Player1">
            </label>

            <div class="avatarSelect">
                <p>Avatar</p>
                <div class="avatarPreview">
                    Capsule + Sphere
                </div>
                <small>(More avatars coming later)</small>
            </div>

            <button id="startButton" class="menuButton start">Start Game</button>
            <button id="settingsButton" class="menuButton settings">Settings</button>

        </div>
    </div>
    <div id="settingsScreen" style="display:none;">
        <div id="settingsPanel">
            <button id="closeSettings" aria-label="Close settings">✕</button>

            <h1>Settings</h1>

            <label>
                Mouse Sensitivity
                <input id="sensInput" type="range" min="0.0001" max="0.03" step="0.0001" value="0.002">
            </label>
            <label>
                <input type="checkbox" id="strafeToggle">
                Turn on strafing for A/D
            </label>

        </div>

    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js?module';
        import { Capsule } from 'https://unpkg.com/three@0.160.0/examples/jsm/math/Capsule.js?module';
        import { Octree } from 'https://unpkg.com/three@0.160.0/examples/jsm/math/Octree.js?module';


        const GameState = { MENU: "menu", SETTINGS: "settings", PLAYING: "playing" };
        const settingsScreen = document.getElementById("settingsScreen");
        const settingsButton = document.getElementById("settingsButton");
        const closeSettingsBtn = document.getElementById("closeSettings");
        const sensInput = document.getElementById("sensInput");
        const strafeToggle = document.getElementById("strafeToggle");
        const startScreen = document.getElementById("startScreen");
        const startButton = document.getElementById("startButton");
        const usernameInput = document.getElementById("usernameInput");
        const yawtextel = document.getElementById("yawtext");
        const posxel = document.getElementById("posx");
        const posyel = document.getElementById("posy");
        const poszel = document.getElementById("posz");
        const usernameHud = document.getElementById("usernameHud");
        const pyodideStatusEl = document.getElementById("pyodideStatus");
        const savedStrafeSetting = localStorage.getItem("useStrafeInsteadOfTurn");

        let gameStarted = false;
        let playerName = "Player";
        let mouseSensitivity = 0.002;
        let currentState = GameState.MENU;
        let previousState = null;
        let useStrafeInsteadOfTurn = false; // default behavior
        let expectingPointerLock = false;
        let pointerLockActive = false;


        useStrafeInsteadOfTurn = savedStrafeSetting === "true";
        strafeToggle.checked = useStrafeInsteadOfTurn;

        // Scene & Renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e1e1e);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting (needed for solid meshes)
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        function createSceneObjects() {
            // Ground and grid
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ color: 0x444444 })
            );
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            const grid = new THREE.GridHelper(100, 100);
            scene.add(grid);

            function createPineTree() {
                const tree = new THREE.Group();

                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.2, 2, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1;
                tree.add(trunk);

                // Foliage layers
                const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x0b6623 });
                const cone1 = new THREE.Mesh(new THREE.ConeGeometry(1.2, 2, 8), foliageMaterial);
                cone1.position.y = 2.4;
                const cone2 = new THREE.Mesh(new THREE.ConeGeometry(1.0, 1.8, 8), foliageMaterial);
                cone2.position.y = 3.4;
                const cone3 = new THREE.Mesh(new THREE.ConeGeometry(0.8, 1.5, 8), foliageMaterial);
                cone3.position.y = 4.3;

                tree.add(cone1, cone2, cone3);

                return tree;
            }

            const pineTree = createPineTree();
            pineTree.position.set(3, 0, -4);
            scene.add(pineTree);


            function init_em_energy() {
                const amount = 100000;
                const positions = new Float32Array(amount * 3);
                const colors = new Float32Array(amount * 3);
                const sizes = new Float32Array(amount);
                const vertex = new THREE.Vector3();
                const color = new THREE.Color(0xffffff);
                const radius = 50;
                const innerRadius = 0; // 0.8 * radius;  // set the hollow inner boundary
                const outerRadius = radius;        // outer boundary of the sphere

                for (let i = 0; i < amount; i++) {

                    // pick a random radius between inner and outer
                    const r = Math.random() * (outerRadius - innerRadius) + innerRadius;

                    // pick random angles
                    const theta = Math.random() * 2 * Math.PI;   // azimuthal angle
                    const phi = Math.acos(2 * Math.random() - 1); // polar angle (uniform distribution)

                    // convert spherical → Cartesian
                    vertex.x = r * Math.sin(phi) * Math.cos(theta);
                    vertex.y = r * Math.sin(phi) * Math.sin(theta);
                    vertex.z = r * Math.cos(phi);
                    vertex.toArray(positions, i * 3);
                    color.setHSL(0.5 + 0.1 * (i / amount), 0.7, 0.5);
                    color.toArray(colors, i * 3);
                    sizes[i] = 0.5;
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.ShaderMaterial({

                    uniforms: {
                        color: { value: new THREE.Color(0xffffff) },
                        pointTexture: { value: new THREE.TextureLoader().load('assets/whitecircle.png') }
                    },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,

                    blending: THREE.AdditiveBlending,
                    depthTest: true,
                    depthWrite: false,
                    transparent: true
                });

                const em_energy = new THREE.Points(geometry, material);
                scene.add(em_energy);
                return em_energy;
            }

            const em_energy = init_em_energy();

            // Halo-style sky object
            const haloGeometry = new THREE.TorusGeometry(15, 0.5, 8, 100);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                wireframe: true
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.set(0, 20, 0);
            halo.rotation.x = Math.PI / 2;
            scene.add(halo);

            // Solid cubes (colliders)
            const cubeMaterialred = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const cubeMaterialblue = new THREE.MeshStandardMaterial({ color: 0x0000ff80 });

            const smallCube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), cubeMaterialred);
            smallCube.position.set(-5, 0.5, -5);
            scene.add(smallCube);

            const mediumCube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), cubeMaterialred);
            mediumCube.position.set(5, 1, 6);
            scene.add(mediumCube);

            const mediumCube2 = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), cubeMaterialred);
            mediumCube2.position.set(6, 3, 6);
            scene.add(mediumCube2);

            const mediumCube3 = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), cubeMaterialred);
            mediumCube3.position.set(7, 5, 6);
            scene.add(mediumCube3);

            const mediumCube4 = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), cubeMaterialred);
            mediumCube4.position.set(8, 7, 6);
            scene.add(mediumCube4);

            const largeCube = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), cubeMaterialblue);
            largeCube.position.set(10, 7, 10);
            scene.add(largeCube);

            const camtargcube = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), cubeMaterialred);
            scene.add(camtargcube);

            // Player avatar (visual only)
            const bodyHeight = 1.0;
            const bodyRadius = 0.3;
            const headRadius = 0.25;
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(bodyRadius, bodyHeight, 4, 8),
                bodyMaterial
            );

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(headRadius, 16, 16),
                headMaterial
            );

            body.position.y = bodyHeight / 2;
            head.position.y = bodyHeight + headRadius;

            const playerAxes = new THREE.AxesHelper(2); // length in units

            const avatar = new THREE.Group();
            avatar.add(body);
            avatar.add(head);
            avatar.add(playerAxes);
            scene.add(avatar);

            return [bodyRadius, bodyHeight, avatar, camtargcube, em_energy];
        }

        const [bodyRadius, bodyHeight, avatar, camtargcube, em_energy] = createSceneObjects();

        // WORLD OCTREE
        const worldOctree = new Octree();
        worldOctree.fromGraphNode(scene);

        // PLAYER CAPSULE (collision truth)
        const playerCapsule = new Capsule(
            new THREE.Vector3(0, bodyRadius, 0),    // location of collider feet 
            new THREE.Vector3(0, bodyHeight + bodyRadius, 0),    //    location of collider head 
            bodyRadius
        );

        // Input
        const keys = {};
        let yaw = 0;
        let pitch = Math.PI / 4;
        let firstPerson = false;
        const UP_LOOK_THRESHOLD = -Math.PI / 24;

        let isRunning = false;

        // Movement & Physics
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const GRAVITY = 30;
        const SPEED = 8;
        const JUMP = 10;

        let onGround = false;

        async function loadPyodideInBackground() {
            try {
                // Load Pyodide loader script dynamically
                const script = document.createElement("script");
                script.src = "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js";
                script.async = true;
                document.head.appendChild(script);

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = reject;
                });

                // Initialize Pyodide
                window.pyodide = await loadPyodide();

                // Create the grid in Python
                await pyodide.loadPackage("numpy")
                await pyodide.runPythonAsync("import numpy as np; grid = np.full((10, 10, 10), 0.1, dtype=np.float32); grid[2:5, 1:15, 3:7] = 3.1");
                // Convert Python grid -> JS typed array
                const pyGrid = pyodide.globals.get("grid");
                window.scalarGrid = pyGrid.toJs({ copy: true });

                // Update HUD when done
                pyodideStatusEl.textContent = "Pyodide loaded";
                pyodideStatusEl.style.color = "#2ecc71";
            } catch (err) {
                console.error("Pyodide failed to load:", err);
                pyodideStatusEl.textContent = "Pyodide failed to load";
                pyodideStatusEl.style.color = "#e74c3c";
            }
        }


        function updatePlayer(delta) {
            direction.set(0, 0, 0);
            if (keys['w']) direction.z -= 1;
            if (keys['s']) direction.z += 1;
            if (useStrafeInsteadOfTurn) {
                if (keys['a']) direction.x -= 1;
                if (keys['d']) direction.x += 1;
            } else {
                if (keys['a']) yaw += 0.07;
                if (keys['d']) yaw -= 0.07;
            }
            if (keys['i']) pitch -= 0.03;
            if (keys['j']) yaw += 0.03;
            if (keys['k']) pitch += 0.03;
            if (keys['l']) yaw -= 0.03;
            if (keys['i'] || keys['k']) {
                pitch = THREE.MathUtils.clamp(
                    pitch,
                    -Math.PI / 2 + 0.1,
                    Math.PI / 2 - 0.1
                );
            }

            const currentSpeed = SPEED * (isRunning ? 2 : 1);
            direction.normalize();
            // Make w/a/s/d relative to camera view rather than static/absolute map directions
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            velocity.x = direction.x * currentSpeed;
            velocity.z = direction.z * currentSpeed;

            if (onGround) {
                velocity.y = Math.max(0, velocity.y);
                if (keys[' ']) velocity.y = JUMP;
            } else {
                velocity.y -= GRAVITY * delta;
            }

            // Move capsule
            const deltaPos = velocity.clone().multiplyScalar(delta);
            playerCapsule.translate(deltaPos);

            // Collision
            const result = worldOctree.capsuleIntersect(playerCapsule);
            onGround = false;

            if (result) {
                playerCapsule.translate(result.normal.multiplyScalar(result.depth));
                onGround = result.normal.y > 0;
            }

            // Sync visual avatar
            avatar.position.copy(playerCapsule.start);
            avatar.rotation.y = yaw;
        }

        // Camera
        function updateCamera() {
            const isCameraInside = false;

            let cameraTarget = avatar.position.clone();

            if (isCameraInside) {
                cameraTarget.x += 0.8 * Math.cos(yaw);
                cameraTarget.z -= 0.8 * Math.sin(yaw);
                camera.position.copy(avatar.position);
            } else {
                const BASE_CAMERA_DISTANCE = 6;
                // Camera points slightly to the right and above avatar
                cameraTarget.x += 0.8 * Math.cos(yaw);
                cameraTarget.z -= 0.8 * Math.sin(yaw);
                cameraTarget.y += 1.7;
                camera.position.x = avatar.position.x - BASE_CAMERA_DISTANCE * Math.cos(yaw + Math.PI / 2) * Math.cos(pitch);
                camera.position.y = avatar.position.y + BASE_CAMERA_DISTANCE * Math.sin(pitch);
                camera.position.z = avatar.position.z + BASE_CAMERA_DISTANCE * Math.sin(yaw + Math.PI / 2) * Math.cos(pitch);
            }
            camtargcube.position.set(cameraTarget.x, cameraTarget.y, cameraTarget.z);
            camera.lookAt(cameraTarget);
        }

        function updateHUD() {
            const pos = playerCapsule.start;
            yawtextel.textContent = yaw.toFixed(3);
            posxel.textContent = pos.x.toFixed(2);
            posyel.textContent = pos.y.toFixed(2);
            poszel.textContent = pos.z.toFixed(2);
        }


        function updateEMfield(time) {
            if (!window.scalarGrid) return; // Pyodide not ready yet

            const geometry = em_energy.geometry;
            const positions = geometry.attributes.position.array;
            const sizes = geometry.attributes.size.array;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                if (x < 0 || y < 0 || z < 0 || x > 9 || y > 9 || z > 9) {
                    sizes[i / 3] = 0;
                } else {
                    const ix = Math.floor(x);
                    const iy = Math.floor(y);
                    const iz = Math.floor(z);

                    // Read scalar value from Pyodide grid
                    const scalar = window.scalarGrid[ix][iy][iz];

                    // Apply it to particle size
                    sizes[i / 3] = scalar;
                }
            }

            geometry.attributes.size.needsUpdate = true;
        }

        // Animate
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            if (currentState !== GameState.PLAYING) {
                renderer.render(scene, camera);
                return;
            }
            const time = performance.now();
            const delta = Math.min(0.03, (time - lastTime) / 1000);
            lastTime = time;

            updatePlayer(delta);
            updateCamera();
            updateHUD();
            updateEMfield(time);
            renderer.render(scene, camera);
        }

        loadPyodideInBackground();
        animate();

        function setState(state) {
            previousState = currentState;
            currentState = state;

            startScreen.style.display =
                state === GameState.MENU ? "flex" : "none";

            settingsScreen.style.display =
                state === GameState.SETTINGS ? "flex" : "none";

            if (state === GameState.PLAYING) {
                document.body.requestPointerLock({ unadjustedMovement: true });
                document.body.style.cursor = "none";
            } else {
                document.exitPointerLock();
                document.body.style.cursor = "default";
            }
        }

        window.addEventListener("keydown", (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === "shift") isRunning = true;
            if (e.key.toLowerCase() === "v") firstPerson = !firstPerson;
            if (e.key === "Escape") {
                e.preventDefault();
                if (currentState === GameState.SETTINGS) { setState(previousState || GameState.MENU); }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key.toLowerCase() === 'shift') isRunning = false;
        });

        document.addEventListener("mousemove", (e) => {
            if (
                currentState !== GameState.PLAYING ||
                document.pointerLockElement !== document.body
            ) return;

            yaw -= e.movementX * mouseSensitivity;
            pitch += e.movementY * mouseSensitivity;

            pitch = THREE.MathUtils.clamp(
                pitch,
                -Math.PI / 2 + 0.1,
                Math.PI / 2 - 0.1
            );
        });

        sensInput.addEventListener("input", e => {
            mouseSensitivity = parseFloat(e.target.value);
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Turn on strafing
        strafeToggle.addEventListener("change", e => {
            useStrafeInsteadOfTurn = e.target.checked;
            localStorage.setItem("useStrafeInsteadOfTurn", useStrafeInsteadOfTurn);
        });

        document.body.addEventListener("click", () => {
            if (currentState === GameState.PLAYING &&
                document.pointerLockElement !== document.body) {
                document.body.requestPointerLock({ unadjustedMovement: true });
            }
        });

        startButton.addEventListener("click", () => {
            playerName = usernameInput.value.trim() || "Player";
            usernameHud.textContent = `Player: ${playerName}`;
            gameStarted = true;
            setState(GameState.PLAYING);
        });

        settingsButton.addEventListener("click", () => {
            setState(GameState.SETTINGS);
        });

        closeSettingsBtn.addEventListener("click", () => {
            setState(previousState || GameState.MENU);
        });


        document.addEventListener("pointerlockchange", () => {
            const locked = document.pointerLockElement === document.body;
            pointerLockActive = locked;

            // Only react if we were already playing AND lock was lost
            if (
                currentState === GameState.PLAYING && !locked
            ) {
                // Delay one frame to avoid click race conditions
                requestAnimationFrame(() => {
                    if (currentState === GameState.PLAYING && !pointerLockActive
                    ) {
                        setState(GameState.SETTINGS);
                    }
                });
            }
        });

    </script>
</body>

</html>