<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Three.js â€“ Capsule Player Avatar</title>
<style>
  body { margin: 0; overflow: hidden; cursor: none; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
  // =====================
  // Scene & Renderer
  // =====================
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1e1e1e);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // =====================
  // Camera
  // =====================
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  // =====================
  // Ground
  // =====================
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true })
  );
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  const grid = new THREE.GridHelper(100, 100);
  scene.add(grid);

  // =====================
  // Reference cubes
  // =====================
  const redWire = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
  const greenWire = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });

  const smallCube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), redWire);
  smallCube.position.set(-5,0.5,-5);
  scene.add(smallCube);

  const largeCube = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), greenWire);
  largeCube.position.set(5,1,5);
  scene.add(largeCube);

  // =====================
  // Player avatar: capsule + head
  // =====================
  const bodyHeight = 1.0;
  const bodyRadius = 0.3;
  const headRadius = 0.25;

  const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
  const headMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });

  const body = new THREE.Mesh(new THREE.CapsuleGeometry(bodyRadius, bodyHeight, 4, 8), bodyMaterial);
  const head = new THREE.Mesh(new THREE.SphereGeometry(headRadius, 16, 16), headMaterial);

  // Position body on ground
  body.position.y = bodyHeight/2;
  head.position.y = bodyHeight + headRadius;
  
  const avatar = new THREE.Group();
  avatar.add(body);
  avatar.add(head);
  scene.add(avatar);

  // =====================
  // Input & movement
  // =====================
  const keys = {};
  let yaw = 0;
  let pitch = Math.PI/4;
  let firstPerson = false;

  let velocityY = 0;
  const gravity = -0.04;
  const jumpStrength = 0.8;

  window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;

    if(e.key.toLowerCase() === 'v') firstPerson = !firstPerson;

    if(e.key === ' ' && avatar.position.y <= bodyHeight/2 + 0.001){
      velocityY = jumpStrength;
    }
  });

  window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  document.body.addEventListener('click', () => document.body.requestPointerLock());

  document.addEventListener('mousemove', (e) => {
    if(document.pointerLockElement !== document.body) return;

    const sensitivity = 0.0005;
    yaw   -= e.movementX * sensitivity;
    pitch += e.movementY * sensitivity;
    pitch = THREE.MathUtils.clamp(pitch, -Math.PI/3, Math.PI/2 - 0.2);
  });

  // =====================
  // Movement & jump
  // =====================
  const speed = 0.08;
  const groundY = bodyHeight/2;

  function updateAvatar() {
    const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const right   = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));

    let moving = false;

    if(keys['w']) { avatar.position.addScaledVector(forward,-speed); moving=true; }
    if(keys['s']) { avatar.position.addScaledVector(forward, speed); moving=true; }
    if(keys['a']) { avatar.position.addScaledVector(right,-speed); moving=true; }
    if(keys['d']) { avatar.position.addScaledVector(right, speed); moving=true; }

    avatar.rotation.y = yaw;

    // Gravity
    velocityY += gravity;
    avatar.position.y += velocityY;

    if(avatar.position.y < groundY){
      avatar.position.y = groundY;
      velocityY = 0;
    }

    return moving;
  }

  // =====================
  // Camera & head bob
  // =====================
  const BASE_CAMERA_DISTANCE = 6;
  const MIN_CAMERA_DISTANCE = 0.05;
  let bobTime = 0;

  function updateCamera(moving){
    let cameraDistance = BASE_CAMERA_DISTANCE;

    // Determine camera target
    let cameraTarget = avatar.position.clone();
    if(firstPerson){
        cameraDistance = MIN_CAMERA_DISTANCE;
        cameraTarget.y += bodyHeight + headRadius; // move to top of head
    }

    // Head bob only in first-person when moving
    let bobOffset = 0;
    if(firstPerson && moving){
        bobTime += 0.1;
        bobOffset = Math.sin(bobTime) * 0.05;
    } else bobTime = 0;

    // Camera offset vector
    const offset = new THREE.Vector3(
        Math.sin(yaw) * Math.cos(pitch),
        Math.sin(pitch) + bobOffset,
        Math.cos(yaw) * Math.cos(pitch)
    ).multiplyScalar(cameraDistance);

    // Position camera and look at target
    camera.position.copy(cameraTarget).add(offset);
    camera.lookAt(cameraTarget);

    // Avatar visibility in first-person
    if(firstPerson){
        // Hide body
        bodyMaterial.opacity = 0;
        bodyMaterial.transparent = true;
        bodyMaterial.wireframe = false; // hide green lines

        // Hide head
        headMaterial.opacity = 0;
        headMaterial.transparent = true;
        headMaterial.wireframe = false; // hide yellow lines
    } else {
        // Restore body
        bodyMaterial.opacity = 1;
        bodyMaterial.transparent = false;
        bodyMaterial.wireframe = true;

        // Restore head
        headMaterial.opacity = 1;
        headMaterial.transparent = false;
        headMaterial.wireframe = true;
    }
}




  // =====================
  // Animate loop
  // =====================
  function animate(){
    requestAnimationFrame(animate);
    const moving = updateAvatar();
    updateCamera(moving);
    renderer.render(scene,camera);
  }
  animate();

  // =====================
  // Resize
  // =====================
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
