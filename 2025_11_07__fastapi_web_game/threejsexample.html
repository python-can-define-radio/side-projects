<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js – Capsule + Octree FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #reticule {
            position: fixed;
            left: 50%;
            top: 50%;
            width: 16px;
            height: 16px;
            margin-left: -8px;
            margin-top: -8px;
            pointer-events: none;
        }

        #reticule span {
            position: absolute;
            background: white;
        }

        #reticule span:nth-child(1) {
            left: 7px;
            top: 0;
            width: 2px;
            height: 16px;
        }

        #reticule span:nth-child(2) {
            top: 7px;
            left: 0;
            width: 16px;
            height: 2px;
        }

        #startScreen {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, #222, #000);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            font-family: monospace;
        }

        #startPanel {
            background: rgba(20, 20, 20, 0.95);
            padding: 24px 32px;
            border: 1px solid #555;
            width: 320px;
            text-align: center;
        }

        #startPanel h1 {
            margin-bottom: 20px;
        }

        #startPanel label {
            display: block;
            margin-bottom: 16px;
            text-align: left;
        }

        #startPanel input {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            background: #111;
            border: 1px solid #555;
            color: white;
        }

        .avatarSelect {
            margin-bottom: 20px;
        }

        .avatarPreview {
            border: 1px solid #555;
            padding: 12px;
            margin: 8px 0;
            background: #111;
        }

        .menuButton {
            width: 100%;
            padding: 10px;
            border: none;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        .menuButton.start {
            background: #2ecc71;
        }

        .menuButton.start:hover {
            background: #27ae60;
        }

        .menuButton.settings {
            background: #3498db;
        }

        .menuButton.settings:hover {
            background: #2980b9;
        }

        #settingsScreen {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            color: white;
            font-family: monospace;
        }

        #settingsPanel {
            background: rgba(20, 20, 20, 0.95);
            padding: 24px 32px;
            border: 1px solid #555;
            width: 320px;
            text-align: center;
        }

        #settingsPanel label {
            display: block;
            margin: 16px 0;
            text-align: left;
        }

        #settingsPanel input[type="range"] {
            width: 100%;
        }

        #settingsPanel {
            position: relative;
        }

        #closeSettings {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            background: #c0392b;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            line-height: 28px;
            cursor: pointer;
        }

        #closeSettings:hover {
            background: #e74c3c;
        }

        .label {
            display: inline-block;
            text-align: center;
            color: white;
            opacity: 0.85;
            letter-spacing: 0.05em;
        }

        #barContainer {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            height: 20px;
            color: white;
            font-size: 1.7em;
            overflow: hidden;
            pointer-events: none;

            /* Fade edges */
            -webkit-mask-image: linear-gradient(to right,
                    transparent 40%,
                    black 48%,
                    black 52%,
                    transparent 60%);
            mask-image: linear-gradient(to right,
                    transparent 40%,
                    black 48%,
                    black 52%,
                    transparent 60%);
        }

        #bar {
            position: absolute;
            display: flex;
            align-items: center;
            /* vertical centering */
            height: 20px;
        }

        #triangle {
            position: absolute;
            top: 100%;
            /* places it just below the barContainer’s bottom edge */
            left: 50%;
            /* center horizontally */
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 15px solid red;
            /* small red triangle pointing up */
        }

        #hud {
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4( color * vColor, 1.0 );
            gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        }
    </script>

    <div id="reticule">
        <span></span>
        <span></span>
    </div>
    <div id="hud" style="position:fixed; top:10px; left:10px; color:white; font-family:monospace;">
        <div id="usernameHud" style="margin-bottom:6px; font-weight:bold;"></div>
        <div>FPS: <span id="fpsCounter">--</span></div>
        Yaw: <span id="yawtext"></span><br>
        Pos:
        <span style="color:#ed8711;">X:</span> <span id="posx"></span>
        <span style="color:#d2ef1b; margin-left:6px;">Y:</span> <span id="posy"></span>
        <span style="color:#4488ff; margin-left:6px;">Z:</span> <span id="posz"></span>
        <div id="pyodideStatus" style="margin-top:6px; color:#aaa;">Pyodide: loading…</div>
    </div>
    <div id="barContainer">
        <div id="bar">
            <div class="label">N</div>
            <div class="label">NE</div>
            <div class="label">E</div>
            <div class="label">SE</div>
            <div class="label">S</div>
            <div class="label">SW</div>
            <div class="label">W</div>
            <div class="label">NW</div>
            <div class="label">N</div>
            <div class="label">NE</div>
            <div class="label">E</div>
            <div class="label">SE</div>
            <div class="label">S</div>
            <div class="label">SW</div>
            <div class="label">W</div>
            <div class="label">NW</div>
            <div class="label">N</div>
            <div class="label">NE</div>
            <div class="label">E</div>
            <div class="label">SE</div>
            <div class="label">S</div>
            <div class="label">SW</div>
            <div class="label">W</div>
            <div class="label">NW</div>
        </div>
        <div id="triangle"></div>
    </div>
    <div id="startScreen">
        <div id="startPanel">
            <h1>Start Game</h1>
            <label>
                Username
                <input id="usernameInput" type="text" maxlength="16" placeholder="Player1">
            </label>
            <div class="avatarSelect">
                <p>Avatar</p>
                <div class="avatarPreview">
                    Capsule + Sphere
                </div>
                <small>(More avatars coming later)</small>
            </div>
            <button id="startButton" class="menuButton start">Start Game</button>
            <button id="settingsButton" class="menuButton settings">Settings</button>
        </div>
    </div>
    <div id="settingsScreen" style="display:none;">
        <div id="settingsPanel">
            <button id="closeSettings" aria-label="Close settings">✕</button>
            <h1>Settings</h1>
            <label>
                Mouse Sensitivity
                <input id="sensInput" type="range" min="0.0001" max="0.03" step="0.0001" value="0.002">
            </label>
            <label>
                <input type="checkbox" id="strafeToggle">
                Turn on strafing for A/D
            </label>
        </div>
    </div>
    <script type="text/python" id="py-grid-script">
        import numpy as np
        gridtimesteps = 50
        grid = np.zeros((50, 5, 50, gridtimesteps), dtype=np.float32)
        for grid_x_high in range(gridtimesteps):
            grid[grid_x_high:grid_x_high+3, 2:5, 20:23, grid_x_high] = 2.3
    </script>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js?module';
        import { Capsule } from 'https://unpkg.com/three@0.160.0/examples/jsm/math/Capsule.js?module';
        import { Octree } from 'https://unpkg.com/three@0.160.0/examples/jsm/math/Octree.js?module';


        const GameState = { MENU: "menu", SETTINGS: "settings", PLAYING: "playing" };
        const settingsScreen = document.getElementById("settingsScreen");
        const settingsButton = document.getElementById("settingsButton");
        const closeSettingsBtn = document.getElementById("closeSettings");
        const sensInput = document.getElementById("sensInput");
        const strafeToggle = document.getElementById("strafeToggle");
        const startScreen = document.getElementById("startScreen");
        const startButton = document.getElementById("startButton");
        const usernameInput = document.getElementById("usernameInput");
        const yawtextel = document.getElementById("yawtext");
        const posxel = document.getElementById("posx");
        const posyel = document.getElementById("posy");
        const poszel = document.getElementById("posz");
        const usernameHud = document.getElementById("usernameHud");
        const pyodideStatusEl = document.getElementById("pyodideStatus");
        const fpsCounterEl = document.getElementById("fpsCounter");
        const savedStrafeSetting = localStorage.getItem("useStrafeInsteadOfTurn");
        const compassDirections = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
        const compassStrip = document.getElementById("compassStrip");
        const bar = document.getElementById("bar");
        const labels = document.getElementsByClassName("label");

        let lastCompassIndex = -1;
        let fpsFrameCount = 0;
        let fpsLastTime = performance.now();
        let fpsValue = 0;
        let gameStarted = false;
        let playerName = "Player";
        let mouseSensitivity = 0.002;
        let currentState = GameState.MENU;
        let previousState = null;
        let useStrafeInsteadOfTurn = false; // default behavior
        let expectingPointerLock = false;
        let pointerLockActive = false;

        useStrafeInsteadOfTurn = savedStrafeSetting === "true";
        strafeToggle.checked = useStrafeInsteadOfTurn;
        bar.style.width = `${5000}px`; // this must be arbitrarily wide so that the compass isn't squished

        // Scene & Renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e1e1e);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting (needed for solid meshes)
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        function createSceneObjects() {
            // Ground and grid
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ color: 0x444444 })
            );
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            const grid = new THREE.GridHelper(100, 100);
            scene.add(grid);

            function createPineTree(x, y, z) {
                const tree = new THREE.Group();

                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.2, 2, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1;
                tree.add(trunk);

                // Foliage layers
                const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x0b6623 });
                const cone1 = new THREE.Mesh(new THREE.ConeGeometry(1.2, 2, 8), foliageMaterial);
                cone1.position.y = 2.4;
                const cone2 = new THREE.Mesh(new THREE.ConeGeometry(1.0, 1.8, 8), foliageMaterial);
                cone2.position.y = 3.4;
                const cone3 = new THREE.Mesh(new THREE.ConeGeometry(0.8, 1.5, 8), foliageMaterial);
                cone3.position.y = 4.3;
                tree.add(cone1, cone2, cone3);
                tree.position.set(x, y, z);
                scene.add(tree);
            }

            function maketreegroup() {
                createPineTree(3, 0, -4);
                createPineTree(15, 0, -12);
                createPineTree(15, 0, -22);
                createPineTree(20, 0, -15);
            }

            function init_em_energy() {
                const amount = 100000;
                const positions = new Float32Array(amount * 3);
                const colors = new Float32Array(amount * 3);
                const sizes = new Float32Array(amount);

                const color = new THREE.Color(0xffffff);

                // SLAB dimensions (world units)
                const SLAB_WIDTH = 50;   // X
                const SLAB_HEIGHT = 5;   // Y (thin)
                const SLAB_DEPTH = 50;   // Z

                for (let i = 0; i < amount; i++) {
                    // Uniform random distribution inside a box
                    const x = Math.random() * SLAB_WIDTH;
                    const y = Math.random() * SLAB_HEIGHT;
                    const z = Math.random() * SLAB_DEPTH;

                    const idx = i * 3;
                    positions[idx] = x;
                    positions[idx + 1] = y;
                    positions[idx + 2] = z;

                    color.setHSL(0.55, 0.7, 0.5);
                    color.toArray(colors, idx);

                    sizes[i] = 0.5;
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(0xffffff) },
                        pointTexture: { value: new THREE.TextureLoader().load('assets/whitecircle.png') }
                    },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    blending: THREE.AdditiveBlending,
                    depthTest: true,
                    depthWrite: false,
                    transparent: true
                });

                const em_energy = new THREE.Points(geometry, material);
                scene.add(em_energy);
                return em_energy;
            }

            const em_energy = init_em_energy();

            // Halo-style sky object
            const haloGeometry = new THREE.TorusGeometry(15, 0.5, 8, 100);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                wireframe: true
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.set(0, 20, 0);
            halo.rotation.x = Math.PI / 2;
            scene.add(halo);

            // Solid cubes (colliders)
            const cubeMaterialred = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const cubeMaterialblue = new THREE.MeshStandardMaterial({ color: 0x0000ff80 });

            const largeCube = new THREE.Mesh(new THREE.BoxGeometry(5, 10, 5), cubeMaterialblue);
            largeCube.position.set(10, 5, 10);
            scene.add(largeCube);

            const camtargcube = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), cubeMaterialred);
            scene.add(camtargcube);

            function makestairs(
                scene,
                startX, startY, startZ,
                direction,
                numStairs,
                width,
                material
            ) {
                const RISE = 0.3;
                const RUN = 0.5;
                const PLATFORM_MULTIPLIER = 4;

                const directions = {
                    N: { x: 0, z: -1 },
                    S: { x: 0, z: 1 },
                    E: { x: 1, z: 0 },
                    W: { x: -1, z: 0 }
                };

                if (!directions[direction]) {
                    throw new Error("Direction must be 'N', 'S', 'E', or 'W'");
                }

                const { x: dx, z: dz } = directions[direction];

                for (let i = 0; i < numStairs; i++) {
                    const isLast = i === numStairs - 1;

                    const height = RISE;
                    const depth = isLast ? RUN * PLATFORM_MULTIPLIER : RUN;

                    let stepWidthX, stepDepthZ;

                    if (direction === "N" || direction === "S") {
                        stepWidthX = width;
                        stepDepthZ = depth;
                    } else {
                        stepWidthX = depth;
                        stepDepthZ = width;
                    }

                    const geometry = new THREE.BoxGeometry(
                        stepWidthX,
                        height,
                        stepDepthZ
                    );

                    const step = new THREE.Mesh(geometry, material);

                    // Offset so deeper platform extends forward
                    const depthOffset = isLast ? (depth - RUN) / 2 : 0;

                    step.position.set(
                        startX + dx * (RUN * i + depthOffset),
                        startY + RISE * i + height / 2,
                        startZ + dz * (RUN * i + depthOffset)
                    );

                    scene.add(step);
                }
            }

            maketreegroup()
            makestairs(scene, -3, 0, -3, "W", 10, 2, cubeMaterialred)
            makestairs(scene, -6, 0, 6.5, "E", 33, 2, cubeMaterialred)
            makestairs(scene, -1, 0, -10, "N", 10, 3, cubeMaterialblue)
            makestairs(scene, -1, 0, -22, "S", 10, 3, cubeMaterialblue)

            // Player avatar (visual only)
            const bodyHeight = 1.0;
            const bodyRadius = .35;
            const headRadius = 0.3;
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(bodyRadius, bodyHeight, 4, 8),
                bodyMaterial
            );

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(headRadius, 16, 16), headMaterial);
            body.position.y = bodyHeight / 2;
            head.position.y = bodyHeight + headRadius;

            const playerAxes = new THREE.AxesHelper(2); // length in units
            scene.add(playerAxes);

            const avatar = new THREE.Group();
            avatar.add(body);
            avatar.add(head);
            scene.add(avatar);

            return [bodyRadius, bodyHeight, avatar, camtargcube, em_energy, playerAxes];
        }

        const [bodyRadius, bodyHeight, avatar, camtargcube, em_energy, playerAxes] = createSceneObjects();

        // WORLD OCTREE
        const worldOctree = new Octree();
        worldOctree.fromGraphNode(scene);

        // PLAYER CAPSULE (collision truth)
        const playerCapsule = new Capsule(
            new THREE.Vector3(0, bodyRadius, 0),    // location of collider feet 
            new THREE.Vector3(0, bodyHeight + bodyRadius, 0),    //    location of collider head 
            bodyRadius
        );

        // Input
        const keys = {};
        let yaw = 0;
        let pitch = Math.PI / 4;
        let firstPerson = false;
        const UP_LOOK_THRESHOLD = -Math.PI / 24;
        let isRunning = false;

        // Movement & Physics
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const GRAVITY = 30;
        const SPEED = 8;
        const JUMP = 10;
        let onGround = false;

        async function loadPyodideInBackground() {
            try {
                const script = document.createElement("script");
                script.src = "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js";
                script.async = true;
                document.head.appendChild(script);

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = reject;
                });

                window.pyodide = await loadPyodide();
                await pyodide.loadPackage("numpy");

                // ⬇️ Execute Python from separate script block
                const pyCode = document.getElementById("py-grid-script").textContent;
                await pyodide.runPythonAsync(pyCode);

                // Extract grid
                const pyGrid = pyodide.globals.get("grid");
                window.scalarGrid = pyGrid.toJs({ copy: true });

                pyodideStatusEl.textContent = "Pyodide loaded";
                pyodideStatusEl.style.color = "#2ecc71";
            } catch (err) {
                console.error(err);
                pyodideStatusEl.textContent = "Pyodide failed";
                pyodideStatusEl.style.color = "#e74c3c";
            }
        }

        function updatePlayer(delta) {
            direction.set(0, 0, 0);
            if (keys['w']) direction.z -= 1;
            if (keys['s']) direction.z += 1;
            if (useStrafeInsteadOfTurn) {
                if (keys['a']) direction.x -= 1;
                if (keys['d']) direction.x += 1;
            } else {
                if (keys['a']) yaw += 0.07;
                if (keys['d']) yaw -= 0.07;
            }
            if (keys['i']) pitch -= 0.03;
            if (keys['j']) yaw += 0.03;
            if (keys['k']) pitch += 0.03;
            if (keys['l']) yaw -= 0.03;
            if (keys['i'] || keys['k']) {
                pitch = THREE.MathUtils.clamp(
                    pitch,
                    -Math.PI / 2 + 0.1,
                    Math.PI / 2 - 0.1
                );
            }
            yaw = normalizeYaw(yaw);

            const currentSpeed = SPEED * (isRunning ? 2 : 1);
            direction.normalize();
            // Make w/a/s/d relative to camera view rather than static/absolute map directions
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            velocity.x = direction.x * currentSpeed;
            velocity.z = direction.z * currentSpeed;

            if (onGround) {
                velocity.y = Math.max(0, velocity.y);
                if (keys[' ']) velocity.y = JUMP;
            } else {
                velocity.y -= GRAVITY * delta;
            }

            // Move capsule
            const deltaPos = velocity.clone().multiplyScalar(delta);
            playerCapsule.translate(deltaPos);

            // Collision
            const result = worldOctree.capsuleIntersect(playerCapsule);
            onGround = false;

            if (result) {
                playerCapsule.translate(result.normal.multiplyScalar(result.depth));
                onGround = result.normal.y > 0;
            }

            // Sync visual avatar
            avatar.position.copy(playerCapsule.start);
            avatar.rotation.y = yaw;
            playerAxes.position.copy(playerCapsule.start);
        }


        function normalizeYaw(yaw) {
            const TWO_PI = Math.PI * 2;
            return ((yaw % TWO_PI) + TWO_PI) % TWO_PI;
        }


        function updateCompass() {
            const degrees = THREE.MathUtils.radToDeg(yaw);
            const corrective_multiplier = 0.47;
            const labelwidth = window.innerWidth * 0.0588;
            const compwid = 8 * labelwidth;
            const x = degrees * corrective_multiplier * window.innerWidth / 360 - compwid;
            [...labels].map(z => z.style.width = `${labelwidth}px`);
            bar.style.left = x + "px";
        }
        window.addEventListener("resize", updateCompass);
        updateCompass();


        // Camera
        function updateCamera() {
            const isCameraInside = false;

            let cameraTarget = avatar.position.clone();

            if (isCameraInside) {
                cameraTarget.x += 0.8 * Math.cos(yaw);
                cameraTarget.z -= 0.8 * Math.sin(yaw);
                camera.position.copy(avatar.position);
            } else {
                const BASE_CAMERA_DISTANCE = 6;
                // Camera points slightly to the right and above avatar
                cameraTarget.x += 0.8 * Math.cos(yaw);
                cameraTarget.z -= 0.8 * Math.sin(yaw);
                cameraTarget.y += 1.7;
                camera.position.x = avatar.position.x - BASE_CAMERA_DISTANCE * Math.cos(yaw + Math.PI / 2) * Math.cos(pitch);
                camera.position.y = avatar.position.y + BASE_CAMERA_DISTANCE * Math.sin(pitch);
                camera.position.z = avatar.position.z + BASE_CAMERA_DISTANCE * Math.sin(yaw + Math.PI / 2) * Math.cos(pitch);
            }
            camtargcube.position.set(cameraTarget.x, cameraTarget.y, cameraTarget.z);
            camera.lookAt(cameraTarget);
        }

        function updateHUD() {
            const pos = playerCapsule.start;
            const yawDeg = (360 - THREE.MathUtils.radToDeg(yaw)) % 360;
            const yawRadNormalized = (2 * Math.PI - yaw) % (2 * Math.PI);
            yawtextel.textContent = `${yawRadNormalized.toFixed(3)} rad | ${((yawRadNormalized * 180 / Math.PI).toFixed(1))}°`;
            posxel.textContent = pos.x.toFixed(2);
            posyel.textContent = pos.y.toFixed(2);
            poszel.textContent = pos.z.toFixed(2);
            updateCompass();

        }

        function updateEMfield(time) {
            if (!window.scalarGrid) return; // Pyodide not ready yet

            const geometry = em_energy.geometry;
            const positions = geometry.attributes.position.array;
            const sizes = geometry.attributes.size.array;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                const gsz = window.scalarGrid.length
                if (x < 0 || y < 0 || z < 0 || x > gsz || y > gsz || z > gsz) {
                    sizes[i / 3] = 0;
                } else {
                    const ix = Math.floor(x);
                    const iy = Math.floor(y);
                    const iz = Math.floor(z);
                    const itime = Math.floor(time / 100) % 50

                    // Read scalar value from Pyodide grid
                    const scalar = window.scalarGrid[ix][iy][iz][itime];

                    // Apply it to particle size
                    sizes[i / 3] = scalar;
                }
            }
            geometry.attributes.size.needsUpdate = true;
        }

        // Animate
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            if (currentState !== GameState.PLAYING) {
                renderer.render(scene, camera);
                return;
            }
            const time = performance.now();
            const deltaMs = time - lastTime;
            const delta = Math.min(0.03, deltaMs / 1000);
            lastTime = time;

            // FPS calculation
            fpsFrameCount++;
            if (time - fpsLastTime >= 500) { // update twice per second
                fpsValue = Math.round((fpsFrameCount * 1000) / (time - fpsLastTime));
                fpsCounterEl.textContent = fpsValue;
                fpsFrameCount = 0;
                fpsLastTime = time;
            }

            updatePlayer(delta);
            updateCamera();
            updateHUD();
            updateEMfield(time);
            renderer.render(scene, camera);
        }

        loadPyodideInBackground();
        animate();

        function setState(state) {
            previousState = currentState;
            currentState = state;

            startScreen.style.display =
                state === GameState.MENU ? "flex" : "none";

            settingsScreen.style.display =
                state === GameState.SETTINGS ? "flex" : "none";

            if (state === GameState.PLAYING) {
                document.body.requestPointerLock({ unadjustedMovement: true });
                document.body.style.cursor = "none";
            } else {
                document.exitPointerLock();
                document.body.style.cursor = "default";
            }
        }

        window.addEventListener("keydown", (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === "shift") isRunning = true;
            if (e.key.toLowerCase() === "v") firstPerson = !firstPerson;
            if (e.key === "Escape") {
                e.preventDefault();
                if (currentState === GameState.SETTINGS) { setState(previousState || GameState.MENU); }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key.toLowerCase() === 'shift') isRunning = false;
        });

        document.addEventListener("mousemove", (e) => {
            if (
                currentState !== GameState.PLAYING ||
                document.pointerLockElement !== document.body
            ) return;

            yaw -= e.movementX * mouseSensitivity;
            yaw = normalizeYaw(yaw);
            pitch += e.movementY * mouseSensitivity;

            pitch = THREE.MathUtils.clamp(
                pitch,
                -Math.PI / 2 + 0.1,
                Math.PI / 2 - 0.1
            );
        });

        sensInput.addEventListener("input", e => {
            mouseSensitivity = parseFloat(e.target.value);
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Turn on strafing
        strafeToggle.addEventListener("change", e => {
            useStrafeInsteadOfTurn = e.target.checked;
            localStorage.setItem("useStrafeInsteadOfTurn", useStrafeInsteadOfTurn);
        });

        document.body.addEventListener("click", () => {
            if (currentState === GameState.PLAYING &&
                document.pointerLockElement !== document.body) {
                document.body.requestPointerLock({ unadjustedMovement: true });
            }
        });

        startButton.addEventListener("click", () => {
            playerName = usernameInput.value.trim() || "Player";
            usernameHud.textContent = `Player: ${playerName}`;
            gameStarted = true;
            setState(GameState.PLAYING);
        });

        settingsButton.addEventListener("click", () => {
            setState(GameState.SETTINGS);
        });

        closeSettingsBtn.addEventListener("click", () => {
            setState(previousState || GameState.MENU);
        });


        document.addEventListener("pointerlockchange", () => {
            const locked = document.pointerLockElement === document.body;
            pointerLockActive = locked;

            // Only react if we were already playing AND lock was lost
            if (
                currentState === GameState.PLAYING && !locked
            ) {
                // Delay one frame to avoid click race conditions
                requestAnimationFrame(() => {
                    if (currentState === GameState.PLAYING && !pointerLockActive
                    ) {
                        setState(GameState.SETTINGS);
                    }
                });
            }
        });

    </script>
</body>

</html>