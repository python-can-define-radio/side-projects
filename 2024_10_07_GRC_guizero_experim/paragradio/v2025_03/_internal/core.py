from distutils.version import StrictVersion
import multiprocessing as mp
import queue
import signal
import sys
import datetime
import time
from typeguard import typechecked
from typing import (
    Type, TypeVar, Generic, Callable,
    Protocol, Tuple, Any, Iterable,
    List, Literal, runtime_checkable, TYPE_CHECKING,
    Union, Optional,
)



T = TypeVar("T")

Tgr = TypeVar("Tgr", bound="gr.top_block")
"""A gr top block or a subclass of such."""


if TYPE_CHECKING:
    from typing_extensions import ParamSpec, Concatenate, TypeAlias
    from gnuradio import gr  # type: ignore[import-untyped]
    from turtle import Turtle
    
    P = ParamSpec("P")

    TPFunc = Callable[Concatenate[T, P], None]
    """A function which takes at least one argument.
    In this particular project, the first argument is most often 
    an instance of `gr.top_block` or any subclass.

    Examples:

    ```python
    def f(tb) -> None: ...
    def f(tb, a) -> None: ...
    def f(tb, a, b) -> None: ...
    def f(tb, a, b, c) -> None: ...
    # etc...
    ```
    """

    _cmdqueue = mp.Queue[Tuple[TPFunc[T, P], Iterable[P.args]]]
    """A queue of tuples. Each tuple is (func, args), 
    where the function's first argument is of type `T` (generic),
    and the functions other args are of "the correct type". Example:
    ```python3
    def f(a: list, b: str, c: int):
        ...
    
    q = mp.Queue()
    args = ("foo", 33)
    q.put((f, args))
    ```
    """


@runtime_checkable
class _AboutToQuitAttr(Protocol):
    def connect(self, f: Callable[[], Any]) -> Any: ...

@runtime_checkable
class _QAppProt(Protocol):
    def exec_(self) -> Any: ...
    aboutToQuit: _AboutToQuitAttr


class ProcessTerminated(RuntimeError):
    ...
    

class UnableToLaunch(RuntimeError):
    ...



def _grc_main_prep(top_block_cls: "Type[Tgr]") -> "Tuple[Tgr, _QAppProt]":
    """This is a copy/paste of the main() function that is generated
    by GRC for Graphical (Qt) flowgraphs. It omits the last line
    of that main function, `qapp.exec_()`, because it is blocking.
    The developer using this function is responsible for running `.exec_()`.
    Example usage 1:
    ```python
    tb, qapp = _grc_main_prep(a_specific_gr_top_block)
    qapp.exec_()
    ```
    Example usage 2:
    ```python
    tb, qapp = _grc_main_prep(a_specific_gr_top_block)
    ## hypothetically, if your `tb` has a signal source block
    tb.signal_source.set_frequency(101.3e6)
    qapp.exec_()
    ```
    """
    from PyQt5 import Qt     # type: ignore[import-untyped]
    from gnuradio import gr

    if StrictVersion("4.5.0") <= StrictVersion(Qt.qVersion()) < StrictVersion("5.0.0"):
        style = gr.prefs().get_string('qtgui', 'style', 'raster')
        Qt.QApplication.setGraphicsSystem(style)
    qapp = Qt.QApplication(sys.argv)

    tb = top_block_cls()
    tb.start()
    tb.show()

    def sig_handler(sig=None, frame=None) -> None:  # type: ignore[no-untyped-def]
        Qt.QApplication.quit()

    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)

    timer = Qt.QTimer()
    timer.start(500)
    timer.timeout.connect(lambda: None)

    def quitting() -> None:
        tb.stop()
        tb.wait()
    qapp.aboutToQuit.connect(quitting)
    assert isinstance(tb, gr.top_block)
    assert isinstance(qapp, _QAppProt)
    assert isinstance(qapp.aboutToQuit, _AboutToQuitAttr)
    return tb, qapp


def _processcmds(instance: "T", q: "_cmdqueue[T, P]") -> None:
    """Pulls a command from the queue `q`, and calls it
    with `instance` as the first argument. `instance` is often a `gr.top_block`
    (which is conventionally named `tb` in the .py files generated by GRC.)"""
    try:
        cmd, args = q.get(block=False)
        cmd(instance, *args)
    except queue.Empty:
        pass


def _event_loop_gr(top_block_cls: "Type[Tgr]", q: "_cmdqueue[Tgr, P]") -> None:
    """Run the Qt/GR process.
    - Sets up the top_block similarly to the `main()` function in the .py file that GRC generates
    - Starts a repeating Qt timer to get and execute commands from `q`
    - Runs the Qt application (assumes that `top_block_cls` is a Qt-based GR flowgraph)"""
    from PyQt5 import Qt
    tb, qapp = _grc_main_prep(top_block_cls)
    timer = Qt.QTimer()
    timer.start(1)
    timer.timeout.connect(lambda: _processcmds(tb, q))
    qapp.aboutToQuit.connect(lambda: print("Gracefully exiting GRC flowgraph."))
    qapp.exec_()


class ParallelGR(Generic[Tgr]):
    def __init__(self, top_block_cls: "Type[Tgr]") -> None:
        self.__q: "_cmdqueue[Tgr, ...]" = mp.Queue()
        self.__proc = mp.Process(target=lambda: _event_loop_gr(top_block_cls, self.__q))

    def start(self) -> None:
        self.__proc.start()

    def put_cmd(self, f: "TPFunc[Tgr, P]", *args: "P.args", **kwargs: "P.kwargs") -> None:
        """Put a command into the queue for the child
        process to execute. Any extra args provided will be
        passed to `f`."""
        if not self.__proc.is_alive():
            raise ProcessTerminated("The parallel process has terminated; cannot execute commands.")
        self.put_cmd_nolivecheck(f, *args, **kwargs)
    
    def put_cmd_nolivecheck(self, f: "TPFunc[Tgr, P]", *args: "P.args", **kwargs: "P.kwargs") -> None:
        """Same as `put_cmd`, but doesn't check that the process is alive."""
        self.__q.put((f, args))
    
    def is_alive(self) -> bool:
        return self.__proc.is_alive()


##### commands for student use

if TYPE_CHECKING:
    from .specan.specan_gr3_8 import specan_gr3_8
    from .specan.specan_gr3_10 import specan_gr3_10
    from .wbfm_rx.wbfm_rx_gr3_8 import wbfm_rx_gr3_8
    from .wbfm_rx.wbfm_rx_gr3_10 import wbfm_rx_gr3_10
    from .noise_tx.noise_tx_gr3_8 import noise_tx_gr3_8
    from .noise_tx.noise_tx_gr3_10 import noise_tx_gr3_10
    from .psk_tx_loop.psk_tx_loop_gr3_8 import psk_tx_loop_gr3_8
    _SpecAn: TypeAlias = Union[specan_gr3_8, specan_gr3_10]
    _Noise_Tx: TypeAlias = Union[noise_tx_gr3_8, noise_tx_gr3_10]    
    _WBFM_Rx: TypeAlias = Union[wbfm_rx_gr3_8, wbfm_rx_gr3_10]
    _PSK_Tx: TypeAlias = psk_tx_loop_gr3_8



def _set_center_freq_child(tb: "_SpecAn", freq: float) -> None:
    tb.set_center_freq(freq)  # type: ignore[no-untyped-call]


def _set_if_gain_child(tb: "_SpecAn", if_gain: float) -> None:
    tb.set_if_gain(if_gain)


def _set_bb_gain_child(tb: "_SpecAn", bb_gain: float) -> None:
    tb.set_bb_gain(bb_gain)


def _set_samp_rate_child(tb: "_SpecAn", samp_rate: float) -> None:
    tb.set_samp_rate(samp_rate)  # type: ignore[no-untyped-call]


def _set_hw_bb_filt_child(tb: "_WBFM_Rx", val: float) -> None:
    tb.set_hw_bb_filt(val)


def _set_freq_offset_child(tb: "_WBFM_Rx", freq_offset: float) -> None:
    tb.set_freq_offset(freq_offset)


def _set_channel_width_child(tb: "_WBFM_Rx", channel_width: float) -> None:
    tb.set_channel_width(channel_width)


def _set_noise_type_child(tb: "_Noise_Tx", noise_type: str) -> None:
    tb.set_noise_type(noise_type)  # type: ignore[no-untyped-call]


def _set_amplitude_child(tb: "_Noise_Tx", amplitude: float) -> None:
    tb.set_amplitude(amplitude)  # type: ignore[no-untyped-call]


def _set_filter_cutoff_freq_child(tb: "_Noise_Tx", filter_cutoff_freq: float) -> None:
    tb.set_filter_cutoff_freq(filter_cutoff_freq)  # type: ignore[no-untyped-call]


def _set_filter_transition_width_child(tb: "_Noise_Tx", filter_transition_width: float) -> None:
    tb.set_filter_transition_width(filter_transition_width)  # type: ignore[no-untyped-call]


def _set_data_child(tb: "_PSK_Tx", data: List[int]) -> None:
    tb.set_data(data)  # type: ignore[no-untyped-call]


def _set_modulation_child(tb: "_PSK_Tx", modulation: "_Modulations") -> None:
    tb.set_modulation(modulation)  # type: ignore[no-untyped-call]


def startnewinstance(cls: "SpecAn") -> None:
    cls._ci = cls()
    cls._ci._pgr.start()
    time.sleep(0.5)
    if not cls._ci._pgr.is_alive():
        raise UnableToLaunch("Possible fixes: plug in Hack RF; ensure there are no other programs using the Hack RF; press reset button on Hack RF")


def decidemakenew(cls: "SpecAn") -> None:
    if cls._ci is None:
        startnewinstance(cls)
    elif not cls._ci._pgr.is_alive():
        ## TODO: Is there cleanup to do on the dead process?
        startnewinstance(cls)


class _EXPLANATIONS:
    amplitude = "\n**amplitude**: The amplitude is ... .\n"
    bb_gain = "\n**bb_gain**: The bb gain is ... .\n"
    center_freq = "\n**center_freq**: The frequency that is ... .\n"
    channel_width = "\n**channel_width**: The channel width is ... .\n"
    data = "\n**data**: The data is ... .\n"
    filter_cutoff_freq = "\n**filter_cutoff_freq**: The filter cutoff frequency is ... .\n"
    filter_transition_width = "\n**filter_transition_width**: The filter transition width is ... .\n"
    freq_offset = "\n**freq_offset**: The frequency offset is ... .\n"
    hw_bb_filt = "\n**hw_bb_filt**: The hardware baseband filter is ... .\n"
    if_gain = "\n**if_gain**: The if gain is ... .\n"
    modulation = "\n**modulation**: The modulation is ... .\n"
    noise_type = "\n**noise_type**: The noise type is ... .\n"
    samp_rate = "\n**samp_rate**: The sample rate is ... .\n"


class SpecAn():
    _ci: "Optional[SpecAn]" = None
    "Current instance"

    def __init__(self) -> None:
        """Create a Paragradio Spectrum Analyzer."""
        from .specan import specan_fg
        self._pgr = ParallelGR(specan_fg)
    
    @classmethod
    def __set_all(cls, center_freq, if_gain, bb_gain, samp_rate, hw_bb_filt):
        cls._ci._pgr.put_cmd(_set_center_freq_child, center_freq)
        cls._ci._pgr.put_cmd(_set_if_gain_child, if_gain)
        cls._ci._pgr.put_cmd(_set_bb_gain_child, bb_gain)
        cls._ci._pgr.put_cmd(_set_samp_rate_child, samp_rate)
        cls._ci._pgr.put_cmd(_set_hw_bb_filt_child, hw_bb_filt)

    @typechecked
    @staticmethod
    def config(
            *,
            center_freq: float = 93e6,
            if_gain: int = 24,
            bb_gain: int = 32,
            samp_rate: float = 2e6,
            hw_bb_filt: float = 2.75e6,
        ) -> dict:
        """If there is not an instance of this Paragradio process running, launch a new one, and set the settings.  
        If one is already running, update the settings of the existing one.
        Returns the timestamp of the update.
        """
        decidemakenew(SpecAn)
        SpecAn.__set_all(center_freq, if_gain, bb_gain, samp_rate, hw_bb_filt)
        return {
            "timestamp": datetime.datetime.now(),
        }


SpecAn.config.__doc__ += _EXPLANATIONS.center_freq + _EXPLANATIONS.if_gain +_EXPLANATIONS.bb_gain + _EXPLANATIONS.samp_rate + _EXPLANATIONS.hw_bb_filt

class SpecAnSim():

    _ci: "Optional[SpecAnSim]" = None
    "Current instance"

    def __init__(self) -> None:
        """Create a Paragradio Simulated Spectrum Analyzer with simulated activity on 93.5 MHz.
        """
        from .specansim import specansim_fg
        self._pgr = ParallelGR(specansim_fg)
        
    def set_center_freq(self, freq: float) -> None:
        """Set the center frequency of simulated spectrum view."""
        super().set_center_freq(freq)

    @classmethod
    def __set_all(cls, center_freq):
        cls._ci._pgr.put_cmd(_set_center_freq_child, center_freq)
       
    @typechecked
    @staticmethod
    def config(
            *,
            center_freq: float = 93e6,
        ) -> dict:
        """If there is not an instance of this Paragradio process running, launch a new one, and set the settings.  
        If one is already running, update the settings of the existing one.
        Returns the timestamp of the update.
        """
        decidemakenew(SpecAnSim)
        SpecAnSim.__set_all(center_freq)
        return {
            "timestamp": datetime.datetime.now(),
        }
    
SpecAnSim.config.__doc__ += _EXPLANATIONS.center_freq

class WBFM_Rx():
    _ci: "Optional[WBFM_Rx]" = None
    "Current instance"

    def __init__(self) -> None:
        """Create a Paragradio Wideband FM Receiver."""
        from .wbfm_rx import wbfm_rx_fg
        self._pgr = ParallelGR(wbfm_rx_fg)
    
    @classmethod
    def __set_all(cls, center_freq, if_gain, bb_gain, hw_bb_filt, freq_offset, channel_width):
        cls._ci._pgr.put_cmd(_set_center_freq_child, center_freq)
        cls._ci._pgr.put_cmd(_set_if_gain_child, if_gain)
        cls._ci._pgr.put_cmd(_set_bb_gain_child, bb_gain)
        cls._ci._pgr.put_cmd(_set_hw_bb_filt_child, hw_bb_filt)
        cls._ci._pgr.put_cmd(_set_freq_offset_child, freq_offset)
        cls._ci._pgr.put_cmd(_set_channel_width_child,channel_width)

    @typechecked
    @staticmethod
    def config(
            *,
            center_freq: float = 93e6,
            if_gain: int = 24,
            bb_gain: int = 32,
            hw_bb_filt: float = 2.75e6,
            freq_offset: float = 0.0,
            channel_width: float = 200e3,
            # Note: Can't add set_samp_rate because the rational resampler doesn't update at runtime
        ) -> dict:
        """If there is not an instance of this Paragradio process running, launch a new one, and set the settings.  
        If one is already running, update the settings of the existing one.
        Returns the timestamp of the update.
        """
        decidemakenew(WBFM_Rx)
        WBFM_Rx.__set_all(center_freq, if_gain, bb_gain, hw_bb_filt, freq_offset, channel_width)
        return {
            "timestamp": datetime.datetime.now(),
        }
    

WBFM_Rx.config.__doc__ += _EXPLANATIONS.center_freq + _EXPLANATIONS.if_gain + _EXPLANATIONS.bb_gain + _EXPLANATIONS.hw_bb_filt + _EXPLANATIONS.freq_offset + _EXPLANATIONS.channel_width


class Noise_Tx():
    _ci: "Optional[Noise_Tx]" = None
    "Current instance"

    def __init__(self) -> None:
        from .noise_tx import noise_tx_fg
        self._pgr = ParallelGR(noise_tx_fg)

    @classmethod
    def __set_all(cls, center_freq, amplitude, if_gain, noise_type, filter_cutoff_freq, filter_transition_width, samp_rate):
        cls._ci._pgr.put_cmd(_set_center_freq_child, center_freq)
        cls._ci._pgr.put_cmd(_set_amplitude_child, amplitude)
        cls._ci._pgr.put_cmd(_set_if_gain_child, if_gain)
        cls._ci._pgr.put_cmd(_set_noise_type_child, noise_type)
        cls._ci._pgr.put_cmd(_set_filter_cutoff_freq_child, filter_cutoff_freq)
        cls._ci._pgr.put_cmd(_set_filter_transition_width_child, filter_transition_width)
        cls._ci._pgr.put_cmd(_set_samp_rate_child, samp_rate)


    @typechecked
    @staticmethod
    def config(
            *,
            center_freq: float = 2.4e9,
            amplitude: float = 0,
            if_gain: int = 0,
            noise_type: Literal["uniform", "gaussian"] = "uniform",
            filter_cutoff_freq: float = 50e3,
            filter_transition_width: float = 200e3,
            samp_rate: float = 2e6,
        ) -> dict:
        """If there is not an instance of this Paragradio process running, launch a new one, and set the settings.  
        If one is already running, update the settings of the existing one.
        Returns the timestamp of the update.

        For more details, run `from paragradio.v2025_03 import Noise_Tx; help(Noise_Tx)`
        """
        decidemakenew(Noise_Tx)
        Noise_Tx.__set_all(center_freq, amplitude, if_gain, noise_type, filter_cutoff_freq, filter_transition_width, samp_rate)
        return {
            "timestamp": datetime.datetime.now(),
        }

Noise_Tx.config.__doc__ += _EXPLANATIONS.center_freq + _EXPLANATIONS.amplitude + _EXPLANATIONS.if_gain + _EXPLANATIONS.noise_type + _EXPLANATIONS.filter_cutoff_freq + _EXPLANATIONS.filter_transition_width + _EXPLANATIONS.samp_rate


if TYPE_CHECKING:
    _Modulations: TypeAlias = Literal["BPSK", "QPSK", "DQPSK", "8PSK", "16QAM"]
modulationslist = ["BPSK", "QPSK", "DQPSK", "8PSK", "16QAM"]


class PSK_Tx_loop():
    _ci: "Optional[PSK_Tx_loop]" = None
    "Current instance"

    def __init__(self, *, modulation = None) -> None:
        if modulation is not None:
            raise ValueError("Due to a recent update, modulation should be set in either (a) the config method, or (b) using `.set_modulation`.")
        from .psk_tx_loop import psk_tx_loop_fg
        self._pgr = ParallelGR(psk_tx_loop_fg)

    @classmethod
    def __set_all(cls, center_freq, if_gain, amplitude, data, samp_rate, modulation):
        cls._ci._pgr.put_cmd(_set_center_freq_child, center_freq)
        cls._ci._pgr.put_cmd(_set_if_gain_child, if_gain)
        cls._ci._pgr.put_cmd(_set_amplitude_child, amplitude)
        cls._ci._pgr.put_cmd(_set_data_child, data)
        cls._ci._pgr.put_cmd(_set_samp_rate_child, samp_rate)
        cls._ci._pgr.put_cmd(_set_modulation_child, modulation)

    @typechecked
    @staticmethod
    def config(
            *,
            center_freq: float = 2.4e9,
            if_gain: int = 0,
            amplitude: float = 0,
            data: List[int],
            samp_rate: float = 2e6,
            modulation: Literal["BPSK", "QPSK", "DQPSK", "8PSK", "16QAM"] = "BPSK",
        ) -> dict:
        """If there is not an instance of this Paragradio process running, launch a new one, and set the settings.  
        If one is already running, update the settings of the existing one.
        Returns the timestamp of the update.
        """
        decidemakenew(PSK_Tx_loop)
        PSK_Tx_loop.__set_all(center_freq, if_gain, amplitude, data, samp_rate, modulation)
        return {
            "timestamp": datetime.datetime.now(),
        }
    

PSK_Tx_loop.config.__doc__ += _EXPLANATIONS.center_freq + _EXPLANATIONS.if_gain + _EXPLANATIONS.amplitude + _EXPLANATIONS.data + _EXPLANATIONS.samp_rate + _EXPLANATIONS.modulation
