# from nullsourcenullsink import nullsourcenullsink
from distutils.version import StrictVersion
import multiprocessing as mp
import signal
import sys
from threading import Thread
import time
from typing import Type, TypeVar, Generic, Callable, Protocol, Tuple, Any, Iterable, List, Literal
from typing_extensions import ParamSpec, Concatenate, runtime_checkable, TYPE_CHECKING


Tgr = TypeVar("Tgr", bound="gr.top_block")
"""A gr top block or a subclass of such."""

T = TypeVar("T")
P = ParamSpec("P")

TPFunc = Callable[Concatenate[T, P], None]
"""A function which takes at least one argument.
In this particular project, the first argument is most often 
an instance of `gr.top_block` or any subclass.

Examples:

```python
def f(tb) -> None: ...
def f(tb, a) -> None: ...
def f(tb, a, b) -> None: ...
def f(tb, a, b, c) -> None: ...
# etc...
```
"""


if TYPE_CHECKING:
    from gnuradio import gr  # type: ignore[import-untyped]
    from turtle import Turtle
    _cmdqueue = mp.Queue[Tuple[TPFunc[T, P], Iterable[P.args]]]



@runtime_checkable
class _AboutToQuitAttr(Protocol):
    def connect(self, f: Callable[[], Any]) -> Any: ...

@runtime_checkable
class _QAppProt(Protocol):
    def exec_(self) -> Any: ...
    aboutToQuit: _AboutToQuitAttr


def _grc_main_prep(top_block_cls: "Type[Tgr]") -> "Tuple[Tgr, _QAppProt]":
    """This is a copy/paste of the main() function that is generated
    by GRC for Graphical (Qt) flowgraphs. It omits the last line
    of that main function, `qapp.exec_()`, because it is blocking.
    The developer using this function is responsible for running `.exec_()`.
    Example usage 1:
    ```python
    tb, qapp = _grc_main_prep(a_specific_gr_top_block)
    qapp.exec_()
    ```
    Example usage 2:
    ```python
    tb, qapp = _grc_main_prep(a_specific_gr_top_block)
    ## hypothetically, if your `tb` has a signal source block
    tb.signal_source.set_frequency(101.3e6)
    qapp.exec_()
    ```
    """
    from PyQt5 import Qt     # type: ignore[import-untyped]
    from gnuradio import gr

    if StrictVersion("4.5.0") <= StrictVersion(Qt.qVersion()) < StrictVersion("5.0.0"):
        style = gr.prefs().get_string('qtgui', 'style', 'raster')
        Qt.QApplication.setGraphicsSystem(style)
    qapp = Qt.QApplication(sys.argv)

    tb = top_block_cls()
    tb.start()
    tb.show()

    def sig_handler(sig=None, frame=None) -> None:  # type: ignore[no-untyped-def]
        Qt.QApplication.quit()

    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)

    timer = Qt.QTimer()
    timer.start(500)
    timer.timeout.connect(lambda: None)

    def quitting() -> None:
        tb.stop()
        tb.wait()
    qapp.aboutToQuit.connect(quitting)
    assert isinstance(tb, gr.top_block)
    assert isinstance(qapp, _QAppProt)
    assert isinstance(qapp.aboutToQuit, _AboutToQuitAttr)
    return tb, qapp


def _processcmds(instance: "T", q: "_cmdqueue[T, P]") -> None:
    """An infinite loop that pulls commands from the queue `q`, and calls them
    with `instance` as the first argument. `instance` is often a `gr.top_block`
    (which is conventionally named `tb` in the .py files generated by GRC.)"""
    while True:
        cmd, args = q.get(block=True)                
        cmd(instance, *args)  # type: ignore[call-arg]


def _event_loop_gr(top_block_cls: "Type[Tgr]", q: "_cmdqueue[Tgr, P]") -> None:
    """Used to run the Qt/GR process."""
    tb, qapp = _grc_main_prep(top_block_cls)
    thread = Thread(target=lambda: _processcmds(tb, q))
    thread.start()
    qapp.aboutToQuit.connect(sys.exit)
    qapp.exec_()


def _event_loop_general(cls: Callable[[], T], q: "_cmdqueue[T, P]", loopfunc: Callable[[], None]) -> None:
    """Used to run a generic process."""
    instance = cls()
    thread = Thread(target=lambda: _processcmds(instance, q))
    thread.start()
    loopfunc()


class ParallelGR(Generic[Tgr]):
    def __init__(self, top_block_cls: "Type[Tgr]") -> None:
        self.__q: _cmdqueue[Tgr, ...] = mp.Queue()
        self.__proc = mp.Process(target=lambda: _event_loop_gr(top_block_cls, self.__q))

    def start(self) -> None:
        self.__proc.start()

    def put_cmd(self, f: "TPFunc[Tgr, P]", *args: "P.args", **kwargs: "P.kwargs") -> None:
        """Put a command into the queue for the child
        process to execute. Any extra args provided will be
        passed to `f`."""
        self.__q.put((f, args))


class ParallelGeneral(Generic[T]):
    def __init__(self, cls: Callable[[], T], loopfunc: Callable[[], None]) -> None:
        self.__q: _cmdqueue[T, ...] = mp.Queue()
        self.__proc = mp.Process(target=lambda: _event_loop_general(cls, self.__q, loopfunc))

    def start(self) -> None:
        self.__proc.start()

    def put_cmd(self, f: "TPFunc[T, P]", *args: "P.args", **kwargs: "P.kwargs") -> None:
        """Put a command into the queue for the child
        process to execute. Any extra args provided will be
        passed to `f`."""
        self.__q.put((f, args))



##### next section is for experimenting without gnuradio

class _xsquaredgrapher:
    def __init__(self) -> None:
        global scale
        scale = 1.0  # type: ignore[name-defined]


def _update_graph_loop() -> None:
    import turtle
    global scale
    while True:
        turtle.clear()
        turtle.penup()
        for x in range(-20, 21):
            y = scale * x**2 - 50   # type: ignore[name-defined]
            turtle.goto(x*5, y*5)
            turtle.pendown()
        time.sleep(0.1)


class P_turtle_xsquared:
    def __init__(self) -> None:
        self.__pg = ParallelGeneral(_xsquaredgrapher, _update_graph_loop)

    def start(self) -> None:
        self.__pg.start()

    @staticmethod
    def _set_scale_child(xsg: _xsquaredgrapher, scale_toset: float) -> None:
        global scale
        scale = scale_toset    # type: ignore[name-defined]

    def set_scale(self, scale: float) -> None:
        """Set the frequency of the signal source block."""
        self.__pg.put_cmd(P_turtle_xsquared._set_scale_child, scale)


##### commands for student use

if TYPE_CHECKING:
    from basicsourcesinkwater import basicsourcesinkwater

class PGR_basicsourcesinkwater:
    def __init__(self) -> None:
        from basicsourcesinkwater import basicsourcesinkwater
        self.__pgr = ParallelGR(basicsourcesinkwater)

    def start(self) -> None:
        self.__pgr.start()

    @staticmethod
    def _set_freq_child(tb: "basicsourcesinkwater", freq: float) -> None:
        tb.analog_sig_source_x_0.set_frequency(freq)

    def set_freq(self, freq: float) -> None:
        """Set the frequency of the signal source block."""
        This_Class = self.__class__
        self.__pgr.put_cmd(This_Class._set_freq_child, freq)


if TYPE_CHECKING:
    from specan import specan

class PGR_specan:
    def __init__(self, freq: float, if_gain: int) -> None:
        from specan import specan
        self.__pgr = ParallelGR(specan)
        self.set_freq(freq)
        self.set_if_gain(if_gain)

    def start(self) -> None:
        self.__pgr.start()

    @staticmethod
    def _set_freq_child(tb: "specan", freq: float) -> None:
        tb.osmosdr_source_0.set_center_freq(freq)
        tb.qtgui_sink_x_0.set_frequency_range(freq, tb.samp_rate)

    def set_freq(self, freq: float) -> None:
        """Set the frequency of the SDR peripheral and the GUI spectrum view."""
        This_Class = self.__class__
        self.__pgr.put_cmd(This_Class._set_freq_child, freq)

    @staticmethod
    def _set_if_gain_child(tb: "specan", gain: float) -> None:
        tb.osmosdr_source_0.set_if_gain(gain)

    def set_if_gain(self, gain: float) -> None:
        """Set the Intermediate Frequency gain of the SDR peripheral."""
        This_Class = self.__class__
        self.__pgr.put_cmd(This_Class._set_if_gain_child, gain)